{
  "name": "FInal-workflow",
  "nodes": [
    {
      "parameters": {
        "jsCode": "// Filter Stage 2 - Emit ONE item per post so Gemini generates exactly ONE script per post\n// Capture the Airtable Record ID from the item object\nconst allItems = $input.all();\nconst output = [];\n\nfor (const item of allItems) {\n  // Debug: Check what structure we're getting\n  const fields = item.json.fields || item.json || {};\n  const status = fields.Status || item.json?.Status || item.json?.status || fields.status || '';\n\n  if (status.toString().trim() === 'Generate Script') {\n    // Try multiple ways to get the record ID\n    const airtable_record_id = item.id || item.json?.id || item.json?.fields?.id || '';\n    const post_id = fields.Post_ID || item.json?.Post_ID || item.json?.fields?.Post_ID || '';\n    \n    const content = fields.Content || item.json?.Content || item.json?.content || '';\n    const transcript = fields.Transcript || item.json?.Transcript || item.json?.transcript || '';\n    const shares = fields.Shares_Awards || item.json?.Shares_Awards || fields.Engagement_Rate || item.json?.engagement_rate || 0;\n    const viral_score = fields.Viral_Score || item.json?.Viral_Score || 0;\n    const hook = fields.Narrative_Hook || item.json?.Narrative_Hook || item.json?.narrative_hook || '';\n    const theme = fields.Visual_Theme || item.json?.Visual_Theme || item.json?.visual_theme || '';\n    const story = fields.Core_Story || item.json?.Core_Story || item.json?.core_story || '';\n    const platform = fields.Platform || item.json?.Platform || item.json?.platform || '';\n\n    const postBlock = `===\\nPost_ID: ${post_id}\\nContent: ${content}\\nTranscript: ${transcript}\\nShares_Awards: ${shares}\\nViral_Score: ${viral_score}\\nNarrative_Hook: ${hook}\\nVisual_Theme: ${theme}\\nCore_Story: ${story}\\nPlatform: ${platform}`;\n\n    output.push({\n      json: {\n        all_viral_content: postBlock,\n        source_record_id: airtable_record_id,\n        source_post_id: post_id,\n        _debug_item_id: item.id,\n        _debug_json_id: item.json?.id\n      }\n    });\n  }\n}\n\nreturn output;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        176,
        -64
      ],
      "id": "6e952e2a-741f-4d21-8b4c-6cac129c76a8",
      "name": "Filter: Status = Generate Script"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=# VIRAL CONTENT ADVERTISING ENGINE\n\n## RAW VIRAL DATA INPUTS\n{{ $json.all_viral_content }}\n\n---\n\n## WHO YOU ARE\nYou are a viral content strategist and direct-response marketer for B2B SaaS.\nYou do NOT write generic ads.\nYou FIRST analyze what type of viral content you are dealing with.\nThen you write a talking head script that matches THAT content type's energy, format, and emotional trigger.\nThe content type determines the script style. Never force a character story onto breaking news. Never force a news format onto a meme. Match the energy.\n\n---\n\n## THE BRANDS (Choose One Per Script)\n1. **ScaleBuild**: Target: Founders/Agencies. Pitch: Build audiences, scale systems, stop grinding manually.\n2. **ScaleLova AI**: Target: Marketers/Ops. Pitch: Automate everything, AI workflows, eliminate 40 hours of manual work.\n\n---\n\n## STEP 1 â€” CLASSIFY THE VIRAL CONTENT TYPE\n\nBefore writing anything, read the post data and assign it ONE of the following content types:\n\n| Type | Description | Script Style to Use |\n|---|---|---|\n| **NEWS** | Breaking news, political event, world event, crisis | Hot Take â€” give a sharp, controversial business opinion on the news |\n| **AI / TECH INNOVATION** | New tool, model launch, tech breakthrough | Authority Play â€” position yourself as the expert who already knew this was coming |\n| **CHARACTER / EMOTION** | A person's story, struggle, triumph, embarrassing moment | Mirror Story â€” make the viewer see themselves in that character's situation |\n| **MEME / HUMOR** | Funny format, absurd situation, relatable joke | Comedian Hook â€” use the joke's punchline structure to land your pitch |\n| **WAR / CONFLICT / TENSION** | Geopolitical conflict, social conflict, confrontation | Stakes Raiser â€” use the conflict's urgency to make business inaction feel dangerous |\n| **SCIENCE / NATURE / DISCOVERY** | Space, biology, animal behavior, environment | Curiosity Hook â€” open with the awe or shock, then pivot to business insight |\n| **SPORTS / COMPETITION** | Athletic achievement, failure, rivalry | Underdog or Champion Frame â€” tie winning/losing to business performance |\n| **FINANCE / ECONOMY** | Markets, recession, inflation, wealth news | Fear or Greed Trigger â€” tap into financial anxiety or ambition |\n| **LIFESTYLE / CULTURE** | Trends, fashion, celebrity, social behavior | Identity Play â€” make the viewer feel left behind or ahead of the curve |\n\n---\n\n## STEP 2 â€” APPLY THE MATCHING SCRIPT STYLE\n\nOnce you have classified the content type, write the script using the rules for THAT type:\n\n---\n\n### IF TYPE = NEWS\n- Open with your HOT TAKE on what this news means for business owners RIGHT NOW.\n- Do not report the news. React to it like a founder who sees the angle no one else does.\n- Example Hook: \\\"Everyone's panicking about [news topic]. Smart operators are doing the opposite.\\\"\n\n---\n\n### IF TYPE = AI / TECH INNOVATION\n- Open by making the viewer feel like they are already behind.\n- Position yourself as someone who saw this coming and already adapted.\n- Example Hook: \\\"While everyone is just hearing about [innovation], I've been using it to automate [specific task] for 3 months.\\\"\n\n---\n\n### IF TYPE = CHARACTER / EMOTION\n- Drop the viewer directly into the character's emotional peak.\n- Make them feel they ARE that person right now.\n- Use the character's conflict as a mirror for a specific business pain.\n- Example Hook: \\\"You know exactly what that feels like. Doing everything right and still watching it fall apart.\\\"\n\n---\n\n### IF TYPE = MEME / HUMOR\n- Use the meme's joke structure (setup -> punchline) but redirect the punchline at a business pain.\n- Keep it light and fast in the hook, then pivot hard to reality in the agitation.\n- Example Hook: \\\"This is literally every founder trusting a VA to handle their entire pipeline manually.\\\"\n\n---\n\n### IF TYPE = WAR / CONFLICT / TENSION\n- Use the urgency and stakes of the conflict to make business complacency feel like surrender.\n- Frame manual work or slow systems as the enemy attacking them daily.\n- Example Hook: \\\"Every day you run your business manually, you are losing ground to someone who already automated it.\\\"\n\n---\n\n### IF TYPE = SCIENCE / NATURE / DISCOVERY\n- Open with the wow moment â€” the fact or discovery that stops the scroll.\n- Immediately pivot: \\\"The same principle is happening in your business right now.\\\"\n- Example Hook: \\\"It took [discovery fact] to happen naturally. Your competition isn't waiting for nature. They're using AI.\\\"\n\n---\n\n### IF TYPE = SPORTS / COMPETITION\n- Frame the viewer as either the underdog who can win or the champion about to be overtaken.\n- Tie athletic performance directly to business systems and speed.\n- Example Hook: \\\"The difference between first and second place is not talent. It's the system behind the athlete.\\\"\n\n---\n\n### IF TYPE = FINANCE / ECONOMY\n- Tap into fear (losing money, falling behind) OR greed (the opportunity hiding in the chaos).\n- Make inaction feel like a financial decision they are already making poorly.\n- Example Hook: \\\"While the market is doing that, your competitors just cut costs by automating their entire ops team.\\\"\n\n---\n\n### IF TYPE = LIFESTYLE / CULTURE\n- Make the viewer feel they are either ahead of a trend or dangerously behind it.\n- Use social identity and status to drive urgency.\n- Example Hook: \\\"The founders still doing this manually are the new people who refused to get a smartphone in 2010.\\\"\n\n---\n\n## STEP 3 â€” UNIVERSAL SCRIPT STRUCTURE (Apply to ALL types)\n\nEvery script follows this structure regardless of content type:\n\n**HOOK (0-4s)**: Stop the scroll. Use the classified style's opening technique. Present tense. Visceral. No \\\"Did you see...\\\" ever.\n\n**AGITATION (4-12s)**: Name the SPECIFIC manual business pain. Not generic. Real tasks. Real consequences. Make them feel it.\n\n**PITCH + CTA (12-20s)**: Position ScaleBuild or ScaleLova AI as the solution that matches the emotional resolution of the content type. One hard CTA.\n\n---\n\n## STRICT RULES\n- 60-70 words max total across all three scenes combined.\n- Never mention the original video, creator, or platform by name.\n- Never say \\\"Did you see...\\\" / \\\"This video...\\\" / \\\"Going viral...\\\"\n- No hashtags in the spoken script.\n- Always write in first or second person only â€” \\\"you\\\" or \\\"I\\\".\n- Name a specific real pain point â€” never vague phrases like \\\"scale your business.\\\"\n- The classified content type's energy must carry through all three scenes.\n\n---\n\n## OUTPUT FORMAT\nReturn ONLY valid JSON. No markdown. No explanation. No extra text.\n\n{\n  \\\"scripts\\\": [\n    {\n      \\\"script_title\\\": \\\"[Brand] - [Content Type] - [Core Hook Angle]\\\",\n      \\\"content_type_detected\\\": \\\"[NEWS / AI-TECH / CHARACTER-EMOTION / MEME / WAR-CONFLICT / SCIENCE / SPORTS / FINANCE / LIFESTYLE]\\\",\n      \\\"script_style_applied\\\": \\\"[Hot Take / Authority Play / Mirror Story / Comedian Hook / Stakes Raiser / Curiosity Hook / Underdog Frame / Fear Trigger / Identity Play]\\\",\n      \\\"core_pain_targeted\\\": \\\"[The specific business task or pain extracted from the viral content context]\\\",\n      \\\"variation\\\": 1,\n      \\\"scenes\\\": [\n        {\n          \\\"type\\\": \\\"hook\\\",\n          \\\"text\\\": \\\"[Scroll-stopping open using the classified style â€” present tense â€” visceral]\\\",\n          \\\"visual\\\": \\\"[Talking head: expression matching the content type energy]\\\",\n          \\\"duration\\\": 4,\n          \\\"avatar_visible\\\": true\n        },\n        {\n          \\\"type\\\": \\\"main\\\",\n          \\\"text\\\": \\\"[Specific business pain agitation â€” real tasks â€” real consequences â€” twist the knife]\\\",\n          \\\"visual\\\": \\\"[B-roll or screen recording matching the pain being described]\\\",\n          \\\"duration\\\": 12,\n          \\\"avatar_visible\\\": false\n        },\n        {\n          \\\"type\\\": \\\"cta\\\",\n          \\\"text\\\": \\\"[Brand as the resolution â€” hard single CTA]\\\",\n          \\\"visual\\\": \\\"[Talking head pointing down with urgency]\\\",\n          \\\"duration\\\": 4,\n          \\\"avatar_visible\\\": true\n        }\n      ],\n      \\\"tone\\\": \\\"[Empathetic-Aggressive / Hot-Take / Comedic-Pivot / Urgent-Authority / Awe-to-Action]\\\",\n      \\\"target_platforms\\\": [\\\"Instagram\\\", \\\"TikTok\\\", \\\"Shorts\\\"],\n      \\\"estimated_duration\\\": 20\n    }\n  ]\n}",
        "batching": {
          "batchSize": 1
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        384,
        -64
      ],
      "id": "2fd173ee-f222-4970-b717-7abdc151cbbf",
      "name": "Generate Video Script",
      "settings": {
        "errorHandling": "continueRegular"
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse AI Script - Extracts ALL scripts and maps source_record_id from Filter node\nconst inputs = $input.all();  // Get ALL inputs from Gemini\nconst filterItems = $items('Filter: Status = Generate Script');  // Get output from Filter node\nconst output = [];\n\n// Create mapping of filter outputs indexed by position\nconst filterMap = {};\nfor (let i = 0; i < filterItems.length; i++) {\n  filterMap[i] = {\n    source_record_id: filterItems[i]?.json?.source_record_id || '',\n    source_post_id: filterItems[i]?.json?.source_post_id || ''\n  };\n}\n\n// Process ALL inputs (each input represents one Gemini response)\nfor (let inputIndex = 0; inputIndex < inputs.length; inputIndex++) {\n  const input = inputs[inputIndex];\n  const rawText = input.json.text || '';\n  \n  // Get source_record_id from the corresponding filter output\n  const filterData = filterMap[inputIndex] || { source_record_id: '', source_post_id: '' };\n  \n  let parsed = {};\n  try {\n    parsed = JSON.parse(rawText);\n  } catch (e) {\n    const jsonMatch = rawText.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) {\n      try {\n        parsed = JSON.parse(jsonMatch[0]);\n      } catch (e2) {}\n    }\n  }\n  \n  const scripts = parsed.scripts || [];\n  \n  // Process ALL scripts within each input\n  for (const script of scripts) {\n    if (script.scenes) {\n      const hook = script.scenes.filter(s => s.type === 'hook').map(s => s.text).join(' ');\n      const main = script.scenes.filter(s => s.type === 'main').map(s => s.text).join(' ');\n      const cta = script.scenes.filter(s => s.type === 'cta').map(s => s.text).join(' ');\n      const visuals = script.scenes.map(s => s.visual).join(' | ');\n      \n      output.push({\n        json: {\n          script_title: script.script_title || 'New Script',\n          source_record_id: filterData.source_record_id,\n          source_post_id: filterData.source_post_id,\n          hook: hook,\n          main_content: main,\n          cta: cta,\n          visual_cues: visuals,\n          tone: script.tone || 'Professional',\n          content_type_detected: script.content_type_detected || '',\n          script_style_applied: script.script_style_applied || '',\n          core_pain_targeted: script.core_pain_targeted || '',\n          target_platforms: script.target_platforms || ['Instagram'],\n          estimated_duration: script.estimated_duration || 20,\n          hashtags: script.hashtags || [],\n          variation: script.variation || 1\n        }\n      });\n    }\n  }\n}\n\nreturn output;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        720,
        -64
      ],
      "id": "parse-ai-script-id",
      "name": "Parse AI Script"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        592,
        96
      ],
      "id": "b0000ff6-0eb8-4e76-ba99-b98e3a00cf2c",
      "name": "Gemini 2.0 Script",
      "credentials": {
        "googlePalmApi": {
          "id": "igaSdthsiO1WHIs5",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "operation": "create",
        "base": {
          "__rl": true,
          "value": "={{ $env.AIRTABLE_BASE_ID }}",
          "mode": "id"
        },
        "table": {
          "__rl": true,
          "value": "={{ $env.AT_TABLE_SCRIPT_LIB }}",
          "mode": "id"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Name": "={{ $json.script_title }}",
            "Source_Content_ID": "={{ $json.source_record_id }}",
            "Script_Title": "={{ $json.script_title }}",
            "Hook": "={{ $json.hook }}",
            "Main_Content": "={{ $json.main_content }}",
            "CTA ": "={{ $json.cta }}",
            "Visual_Cues": "={{ $json.visual_cues }}",
            "Tone": "={{ $json.tone }}",
            "Hashtags": "={{ Array.isArray($json.hashtags) ? $json.hashtags.join(', ') : ($json.hashtags || '') }}",
            "Estimated_Duration": "={{ $json.estimated_duration }}",
            "Target_Platforms ": "={{ Array.isArray($json.target_platforms) ? $json.target_platforms.join(', ') : $json.target_platforms }}",
            "Status": "Pending Approval",
            "Created_Date": "={{ $now.format('yyyy-MM-dd') }}"
          }
        },
        "options": {
          "typecast": true
        }
      },
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [
        928,
        -64
      ],
      "id": "45860e49-ffd7-4dc9-9dcf-c3e81e80b3ab",
      "name": "Store Script in Library",
      "credentials": {
        "airtableTokenApi": {
          "id": "h68hvDXg5Xigfz5P",
          "name": "Airtable Personal Access Token account"
        }
      }
    },
    {
      "parameters": {
        "content": "## ðŸŽ¬ STAGE 2: SCRIPT GENERATION\n\n",
        "height": 416,
        "width": 2552,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -368,
        -176
      ],
      "typeVersion": 1,
      "id": "a72a2661-8a64-408e-a6ee-d20191f40ad4",
      "name": "STAGE 2 - Script Generation"
    },
    {
      "parameters": {},
      "id": "5768a8b4-ff6b-4e3a-b0be-1b2c5c6b99fb",
      "name": "Trigger Generate Script",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -256,
        -48
      ]
    },
    {
      "parameters": {
        "operation": "search",
        "returnAll": true,
        "base": {
          "__rl": true,
          "value": "={{ $env.AIRTABLE_BASE_ID }}",
          "mode": "id"
        },
        "table": {
          "__rl": true,
          "value": "={{ $env.AT_TABLE_VIRAL_DB }}",
          "mode": "id"
        },
        "filterByFormula": "{Status} = 'Generate Script'",
        "options": {}
      },
      "id": "get-analyzed-content-id",
      "name": "Get Analyzed Content",
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [
        -32,
        -48
      ],
      "credentials": {
        "airtableTokenApi": {
          "id": "h68hvDXg5Xigfz5P",
          "name": "Airtable Personal Access Token account"
        }
      }
    },
    {
      "parameters": {
        "content": "## ðŸŽ¥ STAGE 3: ASSET GENERATION\n\n\n**Goal**: Generate raw AI Avatar and Background Assets\n## ðŸŽ¬ STAGE 4: VIDEO EDITING (SHOTSTACK)\n\n**Goal**: Assemble assets into a final video",
        "height": 1154,
        "width": 5020,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -336,
        368
      ],
      "typeVersion": 1,
      "id": "ec0c98ef-1797-4316-8d48-4c160d04425d",
      "name": "STAGE 3 - Video Production"
    },
    {
      "parameters": {
        "content": "## ðŸŽ¯ STAGE 1: CONTENT DISCOVERY PIPELINE\n\n### Flow:\n1ï¸âƒ£ Webhook Trigger â†’ Cron\n2ï¸âƒ£ Google Trends â†’ Viral Keywords\n3ï¸âƒ£ Apify Instagram Reel Scraper â†’ Reel Metadata + URLs\n4ï¸âƒ£ Loop Over Reels\n5ï¸âƒ£ FFmpeg (local) â†’ Extract Audio from Reel URL\n6ï¸âƒ£ Whisper API â†’ Transcription\n7ï¸âƒ£ Gemini â†’ Viral Analysis\n8ï¸âƒ£ Airtable â†’ Store in Viral Content DB\n\n### ENV VARS NEEDED:\n- AIRTABLE_BASE_ID\n- AT_TABLE_VIRAL_DB\n- APIFY_API_TOKEN\n- OPENAI_API_KEY (for Whisper)\n- GOOGLE_GEMINI_API_KEY\n- FFMPEG_TEMP_DIR (e.g. /tmp/reels)",
        "height": 828,
        "width": 6248,
        "color": 4
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -288,
        -1168
      ],
      "typeVersion": 1,
      "id": "note-stage1",
      "name": "STAGE 1 - Overview"
    },
    {
      "parameters": {
        "content": "## STEP 1: TRIGGER\nRuns on schedule or webhook.\nChange cron rule as needed.",
        "height": 180,
        "width": 400,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        320,
        -1280
      ],
      "typeVersion": 1,
      "id": "note-step1",
      "name": "Note Step1"
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours",
              "hoursInterval": 12
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        464,
        -1056
      ],
      "id": "schedule-trigger-id",
      "name": "Schedule Trigger (Every 12h)"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        480,
        -832
      ],
      "id": "webhook-trigger-id",
      "name": "Manual Discovery Trigger"
    },
    {
      "parameters": {
        "content": "## STEP 2: GOOGLE TRENDS\nFetch trending topics from Google Trends RSS.\nParse XML â†’ extract keyword list.",
        "height": 180,
        "width": 400,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        752,
        -1280
      ],
      "typeVersion": 1,
      "id": "note-step2",
      "name": "Note Step2"
    },
    {
      "parameters": {
        "jsCode": "// Generate RSS URLs for 36 countries to maximize viral trend coverage\nconst geos = [\"US\", \"IN\", \"GB\", \"CA\", \"AU\", \"BR\", \"NG\", \"ID\", \"MX\", \"DE\", \"FR\", \"JP\", \"KR\", \"TR\", \"IT\", \"ES\", \"VN\", \"PH\", \"TH\", \"MY\", \"SG\", \"NZ\", \"IE\", \"NL\", \"BE\", \"CH\", \"AT\", \"SE\", \"NO\", \"DK\", \"PL\", \"IL\", \"ZA\", \"EG\", \"SA\", \"AE\"];\nreturn geos.map(geo => ({ json: { geo, url: `https://trends.google.com/trending/rss?geo=${geo}` } }));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        640,
        -992
      ],
      "id": "generate-global-urls-id",
      "name": "Generate Global URLs"
    },
    {
      "parameters": {
        "url": "={{ $json.url }}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "text"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [
        848,
        -992
      ],
      "id": "google-trends-id",
      "name": "Fetch Google Trends RSS"
    },
    {
      "parameters": {
        "jsCode": "// Parse ALL Google Trends RSS feeds â†’ extract FULL metadata + descriptive keywords\nconst items = $input.all();\nconst allTrends = [];\n\nfor (const item of items) {\n  const xml = item.json.data || '';\n  const geo = item.json.geo || 'US';\n  \n  if (!xml || xml.length < 100) continue;\n  \n  // Extract each <item> block from RSS\n  const itemMatches = [...xml.matchAll(/<item>([\\s\\S]*?)<\\/item>/g)];\n  \n  for (const match of itemMatches) {\n    const inner = match[1];\n    \n    // Extract title (keyword)\n    const titleMatch = inner.match(/<title>(?:<!\\[CDATA\\[)?(.*?)(?:\\]\\]>)?<\\/title>/);\n    const title = titleMatch ? titleMatch[1].trim() : '';\n    if (!title || title === 'Daily Search Trends') continue;\n    \n    // Extract approx traffic / search volume\n    const trafficMatch = inner.match(/<ht:approx_traffic>(.*?)<\\/ht:approx_traffic>/);\n    const approx_traffic = trafficMatch ? trafficMatch[1].trim() : '0';\n    \n    // Extract ALL news item titles (context for the trend)\n    const newsItemTitles = [...inner.matchAll(/<ht:news_item_title>(?:<!\\[CDATA\\[)?(.*?)(?:\\]\\]>)?<\\/ht:news_item_title>/g)]\n      .map(m => m[1].trim());\n    \n    // Extract news item sources\n    const newsItemSources = [...inner.matchAll(/<ht:news_item_source>(.*?)<\\/ht:news_item_source>/g)]\n      .map(m => m[1].trim());\n    \n    // Extract news item URLs\n    const newsItemUrls = [...inner.matchAll(/<ht:news_item_url>(?:<!\\[CDATA\\[)?(.*?)(?:\\]\\]>)?<\\/ht:news_item_url>/g)]\n      .map(m => m[1].trim());\n    \n    // Extract picture URL\n    const picMatch = inner.match(/<ht:picture>(?:<!\\[CDATA\\[)?(.*?)(?:\\]\\]>)?<\\/ht:picture>/);\n    const picture = picMatch ? picMatch[1].trim() : '';\n    \n    // Extract pubDate\n    const pubDateMatch = inner.match(/<pubDate>(.*?)<\\/pubDate>/);\n    const pubDate = pubDateMatch ? pubDateMatch[1].trim() : '';\n    \n    // Parse traffic number for sorting\n    const trafficNum = parseInt(approx_traffic.replace(/[^0-9]/g, '')) || 0;\n    \n    // Build descriptive one-sentence keyword using news context\n    const newsContext = newsItemTitles.length > 0 ? newsItemTitles[0] : '';\n    const descriptive_keyword = newsContext \n      ? `${title} - ${newsContext}`\n      : title;\n    \n    allTrends.push({\n      trend_keyword: title,\n      descriptive_keyword: descriptive_keyword,\n      approx_traffic: approx_traffic,\n      traffic_number: trafficNum,\n      news_headlines: newsItemTitles.join(' | '),\n      news_sources: newsItemSources.join(', '),\n      news_urls: newsItemUrls.join(' | '),\n      picture_url: picture,\n      pub_date: pubDate,\n      geo: geo,\n      source: 'Google Trends',\n      fetched_at: new Date().toISOString()\n    });\n  }\n}\n\n// Deduplicate by keyword (case-insensitive)\nconst unique = [];\nconst seen = new Set();\nfor (const t of allTrends) {\n  const key = t.trend_keyword.toLowerCase();\n  if (!seen.has(key)) {\n    seen.add(key);\n    unique.push({ json: t });\n  }\n}\n\n// Sort by traffic (highest first)\nunique.sort((a, b) => (b.json.traffic_number || 0) - (a.json.traffic_number || 0));\n\nreturn unique;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        1056,
        -992
      ],
      "id": "parse-trends-id",
      "name": "Parse All Trends (Full Metadata)"
    },
    {
      "parameters": {
        "jsCode": "// Filter: Keep only VIRAL trends (high traffic) â€” target 500+\n// Keeps everything with 10k+ searches, sorted by traffic descending\nconst items = $input.all();\n\n// Filter: keep trends with meaningful search volume (10k+)\nconst viral = items.filter(item => {\n  const traffic = item.json.traffic_number || 0;\n  return traffic >= 10000;\n});\n\n// If less than 500 after filtering, include ALL trends (don't lose data)\nconst result = viral.length >= 100 ? viral : items;\n\n// Use descriptive keyword as the main trend_keyword for Apify search\nreturn result.map(item => ({\n  json: {\n    ...item.json,\n    trend_keyword: item.json.descriptive_keyword || item.json.trend_keyword\n  }\n}));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        1264,
        -992
      ],
      "id": "limit-keywords-id",
      "name": "Filter Viral Trends (500+)"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=# VIRAL SCOUT â€” MILLION-LIKE POTENTIAL ANALYZER\n\nYou are a viral content analyst. Your job is to determine if this trending topic has REAL viral reel potential â€” the kind of content that gets millions of views on Instagram/TikTok.\n\n## TREND DATA\n- **Topic**: {{ $json.trend_keyword }}\n- **Search Volume**: {{ $json.approx_traffic }}\n- **News Context**: {{ $json.news_headlines || 'N/A' }}\n- **News Sources**: {{ $json.news_sources || 'N/A' }}\n- **Country**: {{ $json.geo }}\n- **Descriptive Keyword**: {{ $json.descriptive_keyword || $json.trend_keyword }}\n\n## VIRAL CATEGORIES (What we want):\n1. **Memes & Bizarre** â€” Penguin walking away from group, unusual animal behavior, absurd news\n2. **Tech & AI Breakthroughs** â€” GPT-5 launch, Chinese humanoid robots, new AI tools\n3. **Celebrity/CEO Moments** â€” Sundar Pichai robot meme, Elon tweets, viral CEO clips\n4. **Shocking News** â€” Court cases, scandals, unexpected revelations\n5. **Innovation & Science** â€” New inventions, space discoveries, medical breakthroughs\n6. **Cultural Phenomena** â€” Viral challenges, dance trends, unexpected heroes\n\n## WHAT TO REJECT:\n- Local sports scores (\"Team X beat Team Y 3-2\")\n- Weather reports\n- Stock market daily movements\n- Local politics with no viral hook\n- Generic celebrity gossip without a meme-worthy angle\n- Regular TV show episode releases\n\n## SCORING RULES:\n- **Tier S (95-100)**: Guaranteed viral. Massive search volume 1M+ AND meme/shock/innovation potential\n- **Tier A (85-94)**: Very high potential. 200k+ searches with strong visual/meme hook\n- **Tier B (70-84)**: Good potential. Has a unique angle that could work for reels\n- **Tier C (50-69)**: Maybe. Needs creative angle to work\n- **REJECT (0-49)**: Not worth Apify credits. Local noise, boring, no reel potential\n\n## YOUR TASK:\n1. Score the viral potential (0-100)\n2. Decide if it's a BANGER (worth spending Apify credits on)\n3. Create an OPTIMIZED Instagram search keyword â€” a vivid sentence for finding viral reels about this topic\n4. Identify the viral angle â€” what makes this topic shareable\n\n## OUTPUT (JSON ONLY, no markdown):\n{\n  \"viral_score\": 0,\n  \"is_banger\": true,\n  \"category\": \"Meme/Tech/Innovation/Bizarre/Celebrity/News\",\n  \"instagram_search_keyword\": \"Vivid one-sentence search phrase optimized for Instagram reel discovery\",\n  \"viral_angle\": \"Why this will go viral in one sentence\",\n  \"reject_reason\": \"Only fill if is_banger is false\"\n}",
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        1952,
        -992
      ],
      "id": "gemini-viral-scout-id",
      "name": "Gemini: Viral Scout",
      "settings": {
        "errorHandling": "continueRegular"
      },
      "onError": "continue"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        2000,
        -800
      ],
      "id": "gemini-scout-model-id",
      "name": "Gemini 2.0 (Scout)",
      "credentials": {
        "googlePalmApi": {
          "id": "igaSdthsiO1WHIs5",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse Gemini Viral Scout results and filter only BANGERS\nconst items = $input.all();\nconst bangers = [];\n\nfor (const item of items) {\n  const rawText = item.json.text || item.json.output || '';\n  let analysis = {};\n  \n  try {\n    analysis = JSON.parse(rawText);\n  } catch(e) {\n    // Try to extract JSON from response\n    const jsonMatch = rawText.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) {\n      try { analysis = JSON.parse(jsonMatch[0]); } catch(e2) {}\n    }\n  }\n  \n  // Only keep bangers (is_banger === true AND viral_score >= 70)\n  if (analysis.is_banger === true && (analysis.viral_score || 0) >= 70) {\n    bangers.push({\n      json: {\n        // Use Gemini's optimized search keyword for Apify\n        trend_keyword: analysis.instagram_search_keyword || item.json.trend_keyword || '',\n        original_keyword: item.json.trend_keyword || '',\n        viral_score: analysis.viral_score || 0,\n        category: analysis.category || 'Unknown',\n        viral_angle: analysis.viral_angle || '',\n        approx_traffic: item.json.approx_traffic || '0',\n        traffic_number: item.json.traffic_number || 0,\n        news_headlines: item.json.news_headlines || '',\n        news_sources: item.json.news_sources || '',\n        picture_url: item.json.picture_url || '',\n        geo: item.json.geo || '',\n        source: item.json.source || 'Google Trends',\n        fetched_at: item.json.fetched_at || new Date().toISOString()\n      }\n    });\n  }\n}\n\n// Sort by viral score (highest first)\nbangers.sort((a, b) => (b.json.viral_score || 0) - (a.json.viral_score || 0));\n\n// Return all bangers (should be much less than 500, saving Apify credits)\nif (bangers.length === 0) {\n  return [{ json: { error: 'No viral bangers found this cycle', total_analyzed: items.length } }];\n}\n\nreturn bangers;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        2288,
        -992
      ],
      "id": "top-viral-bangers-id",
      "name": "Top Viral Bangers"
    },
    {
      "parameters": {
        "jsCode": "// Generate Reddit API URLs for viral subreddits\n// Using hot, rising, and top (past 24h) endpoints\nconst subreddits = ['all', 'technology', 'Futurology', 'worldnews', 'interestingasfuck', 'nextfuckinglevel', 'memes', 'science'];\nconst endpoints = [\n  { type: 'hot', suffix: 'hot.json?limit=30' },\n  { type: 'rising', suffix: 'rising.json?limit=30' },\n  { type: 'top', suffix: 'top.json?t=day&limit=30' }\n];\n\nconst urls = [];\nfor (const sub of subreddits) {\n  for (const ep of endpoints) {\n    urls.push({\n      json: {\n        url: `https://www.reddit.com/r/${sub}/${ep.suffix}`,\n        subreddit: sub,\n        endpoint_type: ep.type\n      }\n    });\n  }\n}\nreturn urls;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        640,
        -720
      ],
      "id": "generate-reddit-urls-id",
      "name": "Generate Reddit URLs"
    },
    {
      "parameters": {
        "url": "={{ $json.url }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "n8n-content-factory/1.0"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          },
          "timeout": 30000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [
        848,
        -720
      ],
      "id": "fetch-reddit-posts-id",
      "name": "Fetch Reddit Posts"
    },
    {
      "parameters": {
        "jsCode": "// Parse Reddit JSON responses â†’ normalize to same format as Google Trends\nconst items = $input.all();\nconst allPosts = [];\n\nfor (const item of items) {\n  const data = item.json.data || item.json;\n  const children = data?.children || [];\n  const subreddit = item.json.subreddit || 'all';\n  const endpointType = item.json.endpoint_type || 'hot';\n  \n  for (const child of children) {\n    const post = child.data || child;\n    if (!post || !post.title) continue;\n    \n    // Skip stickied/pinned posts\n    if (post.stickied) continue;\n    \n    const upvotes = post.ups || post.score || 0;\n    const comments = post.num_comments || 0;\n    const awards = post.total_awards_received || 0;\n    const upvoteRatio = post.upvote_ratio || 0;\n    \n    // Calculate engagement score\n    const engagementScore = upvotes + (comments * 2) + (awards * 10);\n    \n    allPosts.push({\n      trend_keyword: post.title,\n      descriptive_keyword: `${post.title} - r/${post.subreddit || subreddit}`,\n      approx_traffic: `${upvotes.toLocaleString()}+ upvotes`,\n      traffic_number: upvotes,\n      news_headlines: post.title,\n      news_sources: `Reddit r/${post.subreddit || subreddit}`,\n      news_urls: post.url || `https://reddit.com${post.permalink || ''}`,\n      picture_url: (post.thumbnail && post.thumbnail !== 'self' && post.thumbnail !== 'default') ? post.thumbnail : '',\n      pub_date: post.created_utc ? new Date(post.created_utc * 1000).toISOString() : new Date().toISOString(),\n      geo: 'Global',\n      source: 'Reddit',\n      reddit_subreddit: post.subreddit || subreddit,\n      reddit_endpoint: endpointType,\n      reddit_upvotes: upvotes,\n      reddit_comments: comments,\n      reddit_awards: awards,\n      reddit_upvote_ratio: upvoteRatio,\n      reddit_engagement: engagementScore,\n      reddit_permalink: `https://reddit.com${post.permalink || ''}`,\n      fetched_at: new Date().toISOString()\n    });\n  }\n}\n\n// Deduplicate by title\nconst unique = [];\nconst seen = new Set();\nfor (const p of allPosts) {\n  const key = p.trend_keyword.toLowerCase().substring(0, 80);\n  if (!seen.has(key)) {\n    seen.add(key);\n    unique.push({ json: p });\n  }\n}\n\n// Sort by engagement (highest first)\nunique.sort((a, b) => (b.json.reddit_engagement || 0) - (a.json.reddit_engagement || 0));\n\nreturn unique.length > 0 ? unique : [{ json: { error: 'No Reddit posts found', source: 'Reddit' } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        1056,
        -720
      ],
      "id": "parse-reddit-posts-id",
      "name": "Parse Reddit Posts"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        1568,
        -912
      ],
      "id": "merge-sources-id",
      "name": "Merge: Google Trends + Reddit"
    },
    {
      "parameters": {
        "operation": "create",
        "base": {
          "__rl": true,
          "value": "={{ $env.AIRTABLE_BASE_ID }}",
          "mode": "id"
        },
        "table": {
          "__rl": true,
          "value": "={{ $env.AT_TABLE_INSPIRATION }}",
          "mode": "id"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Name": "={{ ($json.original_keyword || $json.trend_keyword || '').substring(0, 100) }}",
            "Platform": "={{ $json.source || 'Google Trends' }}",
            "Search_Keyword": "={{ $json.trend_keyword }}",
            "Category": "={{ $json.category || 'Unknown' }}",
            "Viral_Score": "={{ $json.viral_score || 0 }}",
            "Viral_Angle": "={{ $json.viral_angle || '' }}",
            "Approx_Traffic": "={{ $json.approx_traffic || '0' }}",
            "News_Context": "={{ ($json.news_headlines || '').substring(0, 500) }}",
            "Source_URL": "={{ $json.news_urls || $json.reddit_permalink || '' }}",
            "Geo": "={{ $json.geo || 'Global' }}",
            "Status": "Pending",
            "Created_Date": "={{ $now.format('yyyy-MM-dd') }}"
          }
        },
        "options": {
          "typecast": true
        }
      },
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [
        2464,
        -992
      ],
      "id": "store-inspiration-id",
      "name": "Store in Inspiration DB",
      "credentials": {
        "airtableTokenApi": {
          "id": "h68hvDXg5Xigfz5P",
          "name": "Airtable Personal Access Token account"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        2288,
        -720
      ],
      "id": "trigger-scraping-id",
      "name": "Trigger Scraping Run"
    },
    {
      "parameters": {
        "operation": "search",
        "base": {
          "__rl": true,
          "value": "={{ $env.AIRTABLE_BASE_ID }}",
          "mode": "id"
        },
        "table": {
          "__rl": true,
          "value": "={{ $env.AT_TABLE_INSPIRATION }}",
          "mode": "id"
        },
        "filterByFormula": "{Status} = 'Pending'",
        "returnAll": true,
        "options": {}
      },
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [
        2464,
        -720
      ],
      "id": "read-inspiration-id",
      "name": "Read Inspiration DB (Pending)",
      "credentials": {
        "airtableTokenApi": {
          "id": "h68hvDXg5Xigfz5P",
          "name": "Airtable Personal Access Token account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=# INSTAGRAM REEL SEARCH OPTIMIZER\n\nYou are an expert in Instagram Reels and viral discovery. Your goal is to generate ONE highly effective SEARCH QUERY (a long, vivid descriptive phrase) that will help find the best viral reels for this topic.\n\n## TREND DATA\n- **Name**: {{ $json.Name }}\n- **Platform**: {{ $json.Platform }}\n- **Search Keyword**: {{ $json.Search_Keyword }}\n- **Viral Angle**: {{ $json.Viral_Angle }}\n- **Category**: {{ $json.Category }}\n\n## YOUR TASK:\n1. Analyze the trend and viral angle.\n2. Generate ONE short but vivid search phrase (e.g., \"elon musk robot meme 2024 viral\", \"funny penguin trip ice glitch\").\n3. Do not use # symbols. Just the phrase.\n\n## OUTPUT (JSON ONLY, no markdown):\n{\n  \"search_query\": \"The vivid search phrase optimized for Reel discovery\"\n}",
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        2688,
        -720
      ],
      "id": "gemini-hashtag-optimizer-id",
      "name": "Gemini: Hashtag Optimizer",
      "settings": {
        "errorHandling": "continueRegular"
      },
      "onError": "continue"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        2736,
        -528
      ],
      "id": "gemini-optimizer-model-id",
      "name": "Gemini 2.0 (Optimizer)",
      "credentials": {
        "googlePalmApi": {
          "id": "igaSdthsiO1WHIs5",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse Gemini Keyword Optimizer results in BATCH mode\nconst items = $input.all();\nconst airtableRecords = $(\"Read Inspiration DB (Pending)\").all();\n\nreturn items.map((item, index) => {\n  const rawText = item.json.text || item.json.output || '';\n  let analysis = {};\n  \n  try {\n    analysis = JSON.parse(rawText);\n  } catch(e) {\n    const jsonMatch = rawText.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) {\n      try { analysis = JSON.parse(jsonMatch[0]); } catch(e2) {}\n    }\n  }\n\n  // Get corresponding Airtable record\n  const airtableData = airtableRecords[index]?.json || {};\n\n  // Fallback if no search_query found\n  const query = analysis.search_query || airtableData.Search_Keyword || \"\";\n\n  return {\n    json: {\n      ...airtableData,\n      optimized_query: query\n    }\n  };\n});"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        2944,
        -720
      ],
      "id": "parse-hashtags-id",
      "name": "Parse Keywords"
    },
    {
      "parameters": {
        "content": "## STEP 3: APIFY SCRAPER\nUse Instagram Hashtag / Reel Scraper.\nActor: apify/instagram-reel-scraper\n(or apify/instagram-hashtag-scraper)\n\nReturns: url, likes, comments, views,\nfollowers, caption, timestamp etc.",
        "height": 220,
        "width": 440,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        1296,
        -1312
      ],
      "typeVersion": 1,
      "id": "note-step3",
      "name": "Note Step3"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://api.apify.com/v2/acts/patient_discovery~instagram-search-reels/run-sync-get-dataset-items?token={{ $env.APIFY_API_TOKEN }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\n  \"query\": $json.optimized_query || $json.Search_Keyword,\n  \"resultsLimit\": 10\n} }}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          },
          "timeout": 120000,
          "batching": {
            "batch": {
              "batchSize": 1
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [
        3200,
        -720
      ],
      "id": "apify-scraper-id",
      "name": "Apify: Scrape Instagram Reels",
      "executeOnce": false,
      "notes": "Actor: apify~instagram-reel-scraper\nTimestamp: May take 30-60s. Sync mode returns results directly.\nIf timeout: switch to async run + poll dataset."
    },
    {
      "parameters": {
        "jsCode": "// Normalize Apify Instagram Reel Scraper output (Batch Mode)\nconst airtableKeywords = $items(\"Parse Keywords\");\nlet normalized = [];\n\nconst inputs = $input.all();\ninputs.forEach((input, index) => {\n  // Find the keyword that triggered this specific search\n  const keywordData = airtableKeywords[index] ? airtableKeywords[index].json : {};\n  const parentKeyword = keywordData.optimized_query || keywordData.Search_Keyword || \"\";\n\n  // Handle Apify's variable output structure\n  const raw = input.json;\n  let rawArray = [];\n  if (Array.isArray(raw)) {\n    rawArray = raw;\n  } else if (raw && raw.data && Array.isArray(raw.data)) {\n    rawArray = raw.data;\n  } else if (raw) {\n    rawArray = [raw];\n  }\n\n  // Filter and map this keyword's specific reels\n  const mappedReels = rawArray\n    .filter(item => item && (item.code || item.shortCode || item.shortcode || item.id || item.reel_id))\n    .map(item => {\n      const metrics = item.engagement_metrics || {};\n      const details = item.content_details || {};\n\n      return {\n        json: {\n          // Identity\n          content_code:   item.shortcode || item.code || item.shortCode || item.reel_id || item.id || '',\n          url:            item.url  || `https://www.instagram.com/reel/${item.shortcode || item.code || item.shortCode}/`,\n          video_url:      item.video_url || item.videoUrl || '',\n          platform:       'Instagram',\n\n          // Content / Caption\n          prompt:         details.caption || item.caption?.text || item.text || item.caption || '',\n          timestamp:      item.scraped_at || item.taken_at_ts || item.taken_at || item.timestamp || new Date().toISOString(),\n\n          // Engagement Metrics\n          likes:          metrics.like_count || item.like_count || item.likesCount || 0,\n          comments:       metrics.comment_count || item.comment_count || item.commentsCount || 0,\n          views:          metrics.play_count || item.ig_play_count || item.play_count || item.videoViewCount || 0,\n          shares:         metrics.share_count || item.share_count || item.sharesCount || 0,\n          saves:          metrics.save_count || item.savesCount || item.saves || 0,\n\n          // Subtitles (New)\n          subtitle_url:   item.video_subtitles_uri || '',\n\n          // Author Metadata\n          author:         item.creator?.username || item.user?.username || item.ownerUsername || item.username || '',\n          author_id:      item.creator?.id || item.user?.id || item.ownerId || item.userId || '',\n          followers:      item.creator?.follower_count || item.owner?.followedByCount || 0,\n\n          // Computed\n          engagement_rate: (\n            ((metrics.like_count || 0) + (metrics.comment_count || 0)) /\n            Math.max(metrics.play_count || item.ig_play_count || item.play_count || 1, 1) * 100\n          ).toFixed(2),\n\n          // Pass through optimized query\n          trend_keyword: parentKeyword\n        }\n      };\n    });\n    \n  normalized = normalized.concat(mappedReels);\n});\n\nreturn normalized.length > 0 ? normalized : [{ json: { error: 'No reels found', raw: $input.all() } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        3440,
        -720
      ],
      "id": "normalize-reels-id",
      "name": "Normalize Reel Metadata"
    },
    {
      "parameters": {
        "url": "={{ ($json.subtitle_url && $json.subtitle_url.startsWith('http')) ? $json.subtitle_url : 'https://httpbin.org/status/200' }}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "text"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        3440,
        -960
      ],
      "id": "fetch-subtitles-id",
      "name": "Fetch Subtitles (SRT)",
      "onError": "continueRegular"
    },
    {
      "parameters": {
        "jsCode": "// Clean SRT subtitles into plain text and merge perfectly with original metadata\nconst originalItems = $items(\"Normalize Reel Metadata\");\n\nreturn $input.all().map((item, index) => {\n  const originalReel = originalItems[index] ? originalItems[index].json : {};\n  const srt = item.json.data || \"\";\n  let clean = \"\";\n  \n  if (originalReel.subtitle_url && typeof srt === 'string') {\n    clean = srt\n      .replace(/\\d+\\n\\d{2}:\\d{2}:\\d{2},\\d{3} --> \\d{2}:\\d{2}:\\d{2},\\d{3}/g, \"\")\n      .replace(/<[^>]*>/g, \"\")\n      .replace(/\\n\\s*\\n/g, \"\\n\")\n      .trim();\n  }\n\n  return {\n    json: {\n      ...originalReel,\n      transcript: clean || originalReel.prompt || \"\"\n    }\n  };\n});"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        3648,
        -960
      ],
      "id": "clean-subtitles-id",
      "name": "Clean Subtitles"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=# ScaleBuild AI - Viral Content Analyst\n\n## Viral DNA\n- **Platform**: {{ $json.platform || 'Instagram' }}\n- **Post ID**: {{ $json.content_code }}\n- **Caption/Content**: {{ $json.prompt }}\n- **Transcript (Clean)**: {{ $json.transcript || $json.prompt || 'No transcript available' }}\n- **Likes**: {{ $json.likes }}\n- **Comments**: {{ $json.comments }}\n- **Views**: {{ $json.views }}\n- **Shares**: {{ $json.shares }}\n- **Saves**: {{ $json.saves }}\n- **Engagement Rate**: {{ $json.engagement_rate }}%\n- **Trend Keyword That Found This**: {{ $json.trend_keyword }}\n\n## Task\nAnalyze this viral reel and reverse-engineer its viral chemistry.\nFocus on the STORY, NARRATIVE HOOK, and what made it spread.\nUse the cleaned transcript as the PRIMARY source for understanding the content.\n\nOutput ONLY a valid JSON object. No markdown. No extra text.\n\n{\n  \"viral_score\": 0,\n  \"engagement_score\": 0,\n  \"narrative_hook\": \"\",\n  \"content_structure\": \"\",\n  \"emotional_triggers\": \"\",\n  \"viral_elements\": \"\",\n  \"script_framework\": \"\",\n  \"hook_pattern\": \"\"\n}",
        "batching": {
          "batchSize": 1
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        5040,
        -960
      ],
      "id": "analyze-viral-id",
      "name": "Analyze Viral Content (Gemini)",
      "settings": {
        "errorHandling": "continueRegular"
      },
      "onError": "continue"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        5104,
        -752
      ],
      "id": "gemini-model-id",
      "name": "Gemini 2.0 Flash",
      "credentials": {
        "googlePalmApi": {
          "id": "igaSdthsiO1WHIs5",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parse Gemini's JSON response and perfectly sync with clean metadata\nconst originalItems = $items(\"Clean Subtitles\");\n\nreturn $input.all().map((item, index) => {\n  const originalReel = originalItems[index] ? originalItems[index].json : {};\n  const rawText = item.json.text || item.json.output || '';\n  \n  let analysis = {};\n  try {\n    analysis = JSON.parse(rawText);\n  } catch(e) {\n    // Try to extract JSON block\n    const match = rawText.match(/\\{[\\s\\S]*\\}/);\n    if (match) {\n      try { analysis = JSON.parse(match[0]); } catch(e2) {}\n    }\n  }\n\n  const toString = (val) => {\n    if (val === undefined || val === null) return '';\n    if (typeof val === 'object') return JSON.stringify(val);\n    return String(val);\n  };\n\n  return {\n    json: {\n      ...originalReel,\n      // Gemini Analysis\n      viral_score:        analysis.viral_score || 0,\n      engagement_score:   analysis.engagement_score || 0,\n      narrative_hook:     toString(analysis.narrative_hook || analysis.hook_pattern),\n      hook_pattern:       toString(analysis.hook_pattern   || analysis.narrative_hook),\n      content_structure:  toString(analysis.content_structure),\n      emotional_triggers: toString(analysis.emotional_triggers),\n      viral_elements:     toString(analysis.viral_elements),\n      script_framework:   toString(analysis.script_framework)\n    }\n  };\n});"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [
        5344,
        -960
      ],
      "id": "parse-gemini-id",
      "name": "Parse Gemini Analysis"
    },
    {
      "parameters": {
        "content": "## STEP 8: STORE IN AIRTABLE\nStores all metadata + transcript +\nGemini analysis into Viral Content DB.\n\nAirtable Columns Used:\nName, Post_ID, Platform, Post_URL,\nContent, Engagement_Score, Likes,\nComments, Views, Shares, Saves,\nFollowers, Engagement_Rate, Viral_Score,\nHook_Pattern, Content_Structure,\nEmotional_Triggers, Viral_Elements,\nScript_Framework, Transcript,\nStatus, Created_Date",
        "height": 320,
        "width": 420,
        "color": 2
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        4256,
        -1424
      ],
      "typeVersion": 1,
      "id": "note-step8",
      "name": "Note Step8"
    },
    {
      "parameters": {
        "operation": "create",
        "base": {
          "__rl": true,
          "value": "={{ $env.AIRTABLE_BASE_ID }}",
          "mode": "id"
        },
        "table": {
          "__rl": true,
          "value": "={{ $env.AT_TABLE_VIRAL_DB }}",
          "mode": "id"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Name": "={{ ($json.prompt || $json.content_code || 'Reel').substring(0, 50) }}",
            "Post_ID": "={{ $json.content_code }}",
            "Platform": "={{ $json.platform || 'Instagram' }}",
            "Post_URL": "={{ $json.url }}",
            "Content": "={{ $json.prompt }}",
            "Engagement_Score": "={{ $json.engagement_score }}",
            "Likes_Reactions_Upvotes": "={{ $json.likes }}",
            "Comments": "={{ $json.comments }}",
            "Views": "={{ $json.views }}",
            "Shares": "={{ $json.shares }}",
            "Shares_Awards": "={{ $json.shares }}",
            "Saves": "={{ $json.saves }}",
            "Followers": "={{ $json.followers }}",
            "Engagement_Rate": "={{ $json.engagement_rate }}",
            "Viral_Score": "={{ $json.viral_score }}",
            "Hook_Pattern": "={{ $json.hook_pattern }}",
            "Content_Structure": "={{ $json.content_structure }}",
            "Emotional_Triggers": "={{ $json.emotional_triggers }}",
            "Viral_Elements ": "={{ $json.viral_elements }}",
            "Script_Framework": "={{ $json.script_framework }}",
            "Transcript": "={{ $json.transcript }}",
            "Status": "Analyzed",
            "Created_Date": "={{ $now.format('yyyy-MM-dd') }}"
          }
        },
        "options": {
          "typecast": true
        }
      },
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [
        5600,
        -960
      ],
      "id": "store-viral-db-id",
      "name": "Store in Viral Content DB",
      "credentials": {
        "airtableTokenApi": {
          "id": "h68hvDXg5Xigfz5P",
          "name": "Airtable Personal Access Token account"
        }
      }
    },

    {
      "parameters": {
        "content": "## ðŸŽ¥ STAGE 3: ASSET GENERATION\n**Flow**: Approved Script â†’ ElevenLabs Voice â†’ HeyGen Avatar (Green Screen) â†’ Fetch Viral B-roll â†’ Submagic Assembly\n**Triggers**: Manual trigger for video generation",
        "height": 300,
        "width": 2400,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [-2400, 450],
      "typeVersion": 1,
      "id": "sticky-stage3",
      "name": "STAGE 3 - Asset Generation"
    },

    {
      "parameters": {
        "content": "## ðŸŽ¬ STAGE 4: VIDEO EDITING (SUBMAGIC)\n**Flow**: HeyGen + Viral B-roll â†’ Submagic (Harmozi Effects) â†’ Final Video with Captions & Sync\n**Output**: Final edited video stored in Video RENDERS table",
        "height": 300,
        "width": 2400,
        "color": 4
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [-2400, 770],
      "typeVersion": 1,
      "id": "sticky-stage4",
      "name": "STAGE 4 - Video Editing"
    },

    {
      "parameters": {},
      "id": "manual-s3-s4",
      "name": "Manual Trigger (Stage 3)",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [-2320, 530]
    },

    {
      "parameters": {
        "operation": "search",
        "base": {"__rl": true, "value": "={{ $env.AIRTABLE_BASE_ID }}", "mode": "id"},
        "table": {"__rl": true, "value": "={{ $env.AT_TABLE_SCRIPT_LIB }}", "mode": "id"},
        "filterByFormula": "{Status} = 'Approved'",
        "returnAll": true,
        "options": {}
      },
      "id": "get-approved-scripts-s3s4",
      "name": "Get Approved Scripts",
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [-2080, 570],
      "credentials": {
        "airtableTokenApi": {
          "id": "h68hvDXg5Xigfz5P",
          "name": "Airtable Personal Access Token account"
        }
      }
    },

    {
      "parameters": {
        "conditions": {
          "options": {"caseSensitive": true, "leftValue": "", "typeValidation": "strict"},
          "conditions": [{"id": "has-records", "leftValue": "={{ $input.all().length }}", "rightValue": 0, "operator": {"type": "number", "operation": "gt"}}],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.filter",
      "typeVersion": 2.2,
      "position": [-1880, 570],
      "id": "filter-has-scripts-s3s4",
      "name": "Filter: Has Scripts?"
    },

    {
      "parameters": {
        "jsCode": "const f = $json.fields || $json;\nconst hook = (f.Hook || '').trim();\nconst mainContent = (f.Main_Content || '').trim();\nconst cta = (f['CTA '] || f.CTA || '').trim();\nconst fullScript = [hook, mainContent, cta].filter(Boolean).join('\\n\\n');\nif (!fullScript || fullScript.length < 10) throw new Error(`Script empty for ${$json.id}`);\nreturn [{\n  json: {\n    ...($json),\n    airtable_record_id: $json.id,\n    source_content_id: f.Source_Content_ID || '',\n    script_title: f.Script_Title || f.Name || 'Untitled',\n    full_script: fullScript,\n    hook: hook,\n    main_content: mainContent,\n    cta: cta,\n    visual_prompt: (f.Visual_Cues || 'Professional, cinematic, 8k').trim(),\n    estimated_duration: parseInt(f.Estimated_Duration) || 20,\n    target_platforms: f['Target_Platforms '] || 'TikTok,Instagram',\n    tone: f.Tone || 'Professional'\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [-1680, 570],
      "id": "prepare-script-s3s4",
      "name": "Prepare Full Script"
    },

    {
      "parameters": {
        "jsCode": "const item = $input.first().json;\nreturn [{\n  json: {\n    airtable_record_id: item.airtable_record_id,\n    source_content_id: item.source_content_id,\n    script_title: item.script_title,\n    full_script: item.full_script,\n    visual_prompt: item.visual_prompt,\n    estimated_duration: item.estimated_duration,\n    target_platforms: item.target_platforms,\n    tone: item.tone,\n    elevenlabs_request_body: JSON.stringify({\n      text: item.full_script,\n      model_id: 'eleven_multilingual_v2',\n      voice_settings: {\n        stability: 0.5,\n        similarity_boost: 0.75,\n        style: 0.0,\n        use_speaker_boost: true\n      }\n    })\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [-1480, 570],
      "id": "prepare-elevenlabs-request-s3s4",
      "name": "Prepare ElevenLabs Request"
    },

    {
      "parameters": {
        "method": "POST",
        "url": "=https://api.elevenlabs.io/v1/text-to-speech/{{ $env.ELEVENLABS_VOICE_ID }}",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {"parameters": [{"name": "xi-api-key", "value": "={{ $env.ELEVENLABS_API_KEY }}"}, {"name": "Content-Type", "value": "application/json"}]},
        "sendBody": true,
        "contentType": "json",
        "specifyBody": "body",
        "bodyContent": "={{ $json.elevenlabs_request_body }}",
        "options": {"response": {"response": {"responseFormat": "file"}}}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [-1280, 570],
      "id": "elevenlabs-tts-s3s4",
      "name": "Generate Voice (ElevenLabs)"
    },

    {
      "parameters": {
        "jsCode": "const item = $input.first();\nreturn [{\n  json: {\n    airtable_record_id: item.json.airtable_record_id || '',\n    source_content_id: item.json.source_content_id || '',\n    script_title: item.json.script_title || '',\n    full_script: item.json.full_script || '',\n    visual_prompt: item.json.visual_prompt || '',\n    estimated_duration: item.json.estimated_duration || 20,\n    target_platforms: item.json.target_platforms || '',\n    tone: item.json.tone || ''\n  },\n  binary: item.binary\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [-1280, 570],
      "id": "attach-audio-s3s4",
      "name": "Attach Audio + Metadata"
    },

    {
      "parameters": {
        "method": "POST",
        "url": "https://upload.heygen.com/v1/asset",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {"parameters": [{"name": "X-Api-Key", "value": "={{ $env.HEYGEN_API_KEY }}"}, {"name": "Content-Type", "value": "audio/mpeg"}]},
        "sendBody": true,
        "contentType": "binaryData",
        "inputDataFieldName": "data",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [-1080, 570],
      "id": "upload-audio-heygen-s3s4",
      "name": "Upload Audio to HeyGen"
    },

    {
      "parameters": {
        "jsCode": "const audioUploadResult = $input.first().json;\nconst scriptMeta = $node['Attach Audio + Metadata'].first().json;\nconst audioAssetId = audioUploadResult?.data?.id || audioUploadResult?.id || audioUploadResult?.asset_id || '';\nif (!audioAssetId) throw new Error('HeyGen audio upload failed: ' + JSON.stringify(audioUploadResult));\nreturn [{ json: { ...scriptMeta, audio_asset_id: audioAssetId } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [-880, 570],
      "id": "merge-audio-asset-s3s4",
      "name": "Merge Audio Asset ID"
    },

    {
      "parameters": {
        "method": "POST",
        "url": "https://api.heygen.com/v2/video/generate",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {"parameters": [{"name": "X-Api-Key", "value": "={{ $env.HEYGEN_API_KEY }}"}, {"name": "Content-Type", "value": "application/json"}]},
        "sendBody": true,
        "contentType": "json",
        "specifyBody": "json",
        "jsonBody": "={{ {\"test\": false, \"video_inputs\": [{\"character\": {\"type\": \"avatar\", \"avatar_id\": $env.HEYGEN_AVATAR_ID, \"avatar_style\": \"normal\", \"scale\": 1.0}, \"voice\": {\"type\": \"audio\", \"audio_asset_id\": $json.audio_asset_id}, \"background\": {\"type\": \"color\", \"value\": \"#00FF00\"}}], \"dimension\": {\"width\": 1080, \"height\": 1920}, \"caption\": false} }}"
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [-680, 570],
      "id": "generate-heygen-avatar-s3s4",
      "name": "HeyGen: Generate Avatar (Green Screen)"
    },

    {
      "parameters": {
        "jsCode": "const heygenResponse = $input.first().json;\nconst scriptMeta = $node['Merge Audio Asset ID'].first().json;\nconst videoId = heygenResponse?.data?.video_id || heygenResponse?.video_id || '';\nif (!videoId) throw new Error('HeyGen failed: ' + JSON.stringify(heygenResponse));\nreturn [{ json: { ...scriptMeta, heygen_video_id: videoId } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [-480, 570],
      "id": "extract-heygen-video-id-s3s4",
      "name": "Extract HeyGen Video ID"
    },

    {
      "parameters": {
        "amount": 10,
        "unit": "minutes"
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1,
      "position": [-280, 570],
      "id": "wait-heygen-s3s4",
      "name": "Wait 10 Min (HeyGen)"
    },

    {
      "parameters": {
        "jsCode": "// Extract the ACTUAL SCENE/NARRATIVE from viral content\nconst viralContent = $input.first().json;\nconst fields = viralContent.fields || viralContent;\n\n// Extract story elements\nconst caption = fields.Caption || fields.caption || '';\nconst transcript = fields.Transcript || fields.transcript || '';\nconst content = fields.Content || fields.content || fields.Description || fields.description || '';\n\n// Combine transcript and content to get the full narrative\nconst fullNarrative = `${transcript} ${content}`;\n\n// Build VEO prompt focusing on the actual SCENE to generate (not talking head)\n// This should describe what objects, characters, actions, emotions are in the story\nconst veoPrompt = `Generate a real-world footage scene based on this story: \"${fullNarrative.substring(0, 500)}\". The scene should depict the actual narrative elements, characters, objects, emotions, and actions described. This is NOT a talking head - it's the real scene/action happening. High production value, 4K cinematic quality, realistic lighting and environment. Make it align exactly with the story being told.`;\n\nreturn [{ json: { ...viralContent, veo_prompt: veoPrompt, story_narrative: fullNarrative, viral_caption: caption, viral_transcript: transcript, viral_content: content } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [0, 700],
      "id": "build-visual-prompt-viral-s3s4",
      "name": "Extract Scene Narrative (for VEO)"
    },

    {
      "parameters": {
        "method": "POST",
        "url": "https://api.veo.co/v1/generate",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer {{ $env.VEO_API_KEY }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "contentType": "json",
        "specifyBody": "json",
        "jsonBody": "={{ {\"prompt\": $json.veo_prompt || \"Generate a real scene aligned with the story narrative\", \"duration\": 10, \"quality\": \"high\", \"aspect_ratio\": \"16:9\"} }}"
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [190, 700],
      "id": "veo-generate-real-footage-s3s4",
      "name": "VEO: Generate Real Footage"
    },

    {
      "parameters": {
        "jsCode": "const response = $input.first().json;\nif (response.id) {\n  return [{ json: { ...response, veo_task_id: response.id, veo_status: 'generating' } }];\n}\nreturn [{ json: { error: 'No task ID returned from VEO API' } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [380, 700],
      "id": "extract-veo-task-id-s3s4",
      "name": "Extract VEO Task ID"
    },

    {
      "parameters": {
        "amount": 10,
        "unit": "minutes"
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1,
      "position": [570, 700],
      "id": "wait-veo-s3s4",
      "name": "Wait 10 Min (VEO)",
      "webhookId": "veo-wait-webhook"
    },

    {
      "parameters": {
        "method": "GET",
        "url": "={{ \"https://api.veo.co/v1/tasks/\" + $json.veo_task_id }}",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer {{ $env.VEO_API_KEY }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [760, 700],
      "id": "poll-veo-status-s3s4",
      "name": "Poll VEO Status"
    },

    {
      "parameters": {
        "jsCode": "const response = $input.first().json;\nconst status = response.status || 'unknown';\nconst videoUrl = response.result?.url || response.video_url || '';\n\nif (status === 'completed' && videoUrl && videoUrl !== 'null') {\n  return [{ json: { ...response, veo_status: 'completed', veo_video_url: videoUrl } }];\n}\nif (status === 'processing' || status === 'queued') {\n  return [{ json: { ...response, veo_status: 'processing', __retry: true } }];\n}\nreturn [{ json: { error: `VEO generation failed with status: ${status}`, ...response } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [950, 700],
      "id": "classify-veo-status-s3s4",
      "name": "Classify VEO Status"
    },

    {
      "parameters": {
        "operation": "search",
        "base": {"__rl": true, "value": "={{ $env.AIRTABLE_BASE_ID }}", "mode": "id"},
        "table": {"__rl": true, "value": "={{ $env.AT_TABLE_VIRAL_DB }}", "mode": "id"},
        "filterByFormula": "RECORD_ID() = '{source_content_id}'",
        "returnAll": false,
        "options": {}
      },
      "id": "fetch-viral-content-s3s4",
      "name": "Fetch Viral Content (B-roll)",
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [-80, 570],
      "credentials": {
        "airtableTokenApi": {
          "id": "h68hvDXg5Xigfz5P",
          "name": "Airtable Personal Access Token account"
        }
      }
    },

    {
      "parameters": {
        "jsCode": "const viralContent = $input.first().json;\nconst fields = viralContent.fields || viralContent;\nconst postUrl = fields.Post_URL || fields.post_url || '';\nif (!postUrl || !postUrl.startsWith('http')) {\n  console.warn('Viral content URL missing/invalid');\n  return [{ json: { ...viralContent, viral_b_roll_url: '' } }];\n}\nreturn [{ json: { ...viralContent, viral_b_roll_url: postUrl } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [120, 570],
      "id": "extract-viral-broll-s3s4",
      "name": "Extract Viral B-Roll URL"
    },

    {
      "parameters": {
        "method": "GET",
        "url": "={{ \"https://api.heygen.com/v1/video_status.get?video_id=\" + $json.heygen_video_id }}",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {"parameters": [{"name": "X-Api-Key", "value": "={{ $env.HEYGEN_API_KEY }}"}]},
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [320, 570],
      "id": "poll-heygen-status-s3s4",
      "name": "Poll HeyGen Status"
    },

    {
      "parameters": {
        "jsCode": "const status = $input.first().json?.data?.status || $input.first().json?.status || '';\nconst videoUrl = $input.first().json?.data?.video_url || $input.first().json?.video_url || '';\nif (status === 'completed' && videoUrl && videoUrl !== 'null') {\n  return [{ json: { ...$input.first().json, heygen_status: 'completed', heygen_video_url: videoUrl } }];\n}\nreturn [{ json: { __skip: true } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [520, 570],
      "id": "classify-heygen-s3s4",
      "name": "Classify HeyGen Status"
    },

    {
      "parameters": {
        "conditions": {
          "options": {"caseSensitive": true, "leftValue": "", "typeValidation": "strict"},
          "conditions": [{"id": "heygen-ready", "leftValue": "={{ $json.heygen_status }}", "rightValue": "completed", "operator": {"type": "string", "operation": "equals"}}],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.filter",
      "typeVersion": 2.2,
      "position": [720, 570],
      "id": "filter-heygen-ready-s3s4",
      "name": "Filter: HeyGen Ready?"
    },

    {
      "parameters": {
        "jsCode": "// Combine data from all previous steps\nconst classifyVeoNode = $node['Classify VEO Status']?.first()?.json || {};\nconst viralContentData = $input.first().json || {};\n\n// Merge all data, prioritizing viral content data\nconst mergedData = {\n  ...classifyVeoNode,\n  ...viralContentData,\n  veo_video_url: classifyVeoNode.veo_video_url|| '',\n  heygen_video_id: classifyVeoNode.heygen_video_id || '',\n  viral_b_roll_url: viralContentData.viral_b_roll_url || viralContentData.Post_URL || '',\n  veo_prompt: viralContentData.veo_prompt || classifyVeoNode.veo_prompt || '',\n  story_narrative: viralContentData.story_narrative || '',\n  viral_caption: viralContentData.viral_caption || viralContentData.Caption || '',\n  viral_transcript: viralContentData.viral_transcript || viralContentData.Transcript || '',\n  viral_content: viralContentData.viral_content || viralContentData.Content || '',\n  airtable_record_id: classifyVeoNode.airtable_record_id || classifyVeoNode.id || '',\n  source_content_id: classifyVeoNode.source_content_id || classifyVeoNode.Source_Content_ID || viralContentData.id || ''\n};\n\nreturn [{ json: mergedData }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [920, 570],
      "id": "merge-assets-data-s3s4",
      "name": "Merge All Assets Data"
    },

    {
      "parameters": {
        "operation": "update",
        "base": {"__rl": true, "value": "={{ $env.AIRTABLE_BASE_ID }}", "mode": "id"},
        "table": {"__rl": true, "value": "={{ $env.AT_TABLE_SCRIPT_LIB }}", "mode": "id"},
        "recordId": "={{ $json.airtable_record_id }}",
        "columns": {"mappingMode": "defineBelow", "value": {"HeyGen_Video_ID": "={{ $json.heygen_video_id }}", "Real_Footage_URL": "={{ $json.veo_video_url || '' }}", "Status": "Pending Submagic"}},
        "options": {}
      },
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [1120, 570],
      "id": "update-script-pending-submagic-s3s4",
      "name": "Update Script: Pending Submagic",
      "credentials": {
        "airtableTokenApi": {
          "id": "h68hvDXg5Xigfz5P",
          "name": "Airtable Personal Access Token account"
        }
      }
    },

    {
      "parameters": {
        "method": "POST",
        "url": "https://api.submagic.co/v1/projects",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {"parameters": [{"name": "x-api-key", "value": "={{ $env.SUBMAGIC_API_KEY }}"}, {"name": "Content-Type", "value": "application/json"}]},
        "sendBody": true,
        "contentType": "json",
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\"title\": $json.script_title, \"language\": \"en\", \"videoUrl\": $json.heygen_video_url, \"realFootageUrl\": ($json.veo_video_url || ''), \"brollUrl\": ($json.viral_b_roll_url || ''), \"templateName\": \"Hormozi 2\", \"magicBrolls\": true, \"magicBrollsPercentage\": 40, \"magicZooms\": true, \"captions\": true, \"captionStyle\": \"modern\"}) }}"
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [1320, 570],
      "id": "submit-submagic-s3s4",
      "name": "Submit to Submagic"
    },

    {
      "parameters": {
        "jsCode": "const submagicResponse = $input.first().json;\nconst projectId = submagicResponse?.id || submagicResponse?.project_id || submagicResponse?.data?.id || '';\nif (!projectId) throw new Error('Submagic failed: ' + JSON.stringify(submagicResponse));\nreturn [{ json: { ...submagicResponse, submagic_project_id: projectId, submagic_status: 'processing' } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1520, 570],
      "id": "extract-submagic-id-s3s4",
      "name": "Extract Submagic Project ID"
    },

    {
      "parameters": {
        "amount": 5,
        "unit": "minutes"
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1,
      "position": [1720, 570],
      "id": "wait-submagic-s3s4",
      "name": "Wait 5 Min (Submagic)"
    },

    {
      "parameters": {
        "method": "GET",
        "url": "={{ \"https://api.submagic.co/v1/projects/\" + $json.submagic_project_id }}",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {"parameters": [{"name": "x-api-key", "value": "={{ $env.SUBMAGIC_API_KEY }}"}]},
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [1720, 1900],
      "id": "poll-submagic-status-s3s4",
      "name": "Poll Submagic Status"
    },

    {
      "parameters": {
        "jsCode": "const status = ($input.first().json?.status || $input.first().json?.data?.status || '').toLowerCase();\nconst videoUrl = $input.first().json?.video_url || $input.first().json?.output_url || $input.first().json?.data?.video_url || $input.first().json?.downloadUrl || '';\nconst isComplete = (status === 'completed' || status === 'done' || status === 'finished') && videoUrl.length > 0;\nreturn [{ json: { ...$node['Extract Submagic Project ID'].first().json, submagic_current_status: status, submagic_video_url: videoUrl, is_complete: isComplete } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [1920, 2050],
      "id": "evaluate-submagic-status-s3s4",
      "name": "Evaluate Submagic Status"
    },

    {
      "parameters": {
        "conditions": {
          "options": {"caseSensitive": false, "leftValue": "", "typeValidation": "strict"},
          "conditions": [{"id": "submagic-complete", "leftValue": "={{ $json.is_complete }}", "rightValue": true, "operator": {"type": "boolean", "operation": "true", "singleValue": true}}],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [2120, 2200],
      "id": "check-submagic-complete-s3s4",
      "name": "Is Submagic Complete?"
    },

    {
      "parameters": {
        "operation": "update",
        "base": {"__rl": true, "value": "={{ $env.AIRTABLE_BASE_ID }}", "mode": "id"},
        "table": {"__rl": true, "value": "={{ $env.AT_TABLE_SCRIPT_LIB }}", "mode": "id"},
        "recordId": "={{ $json.airtable_record_id }}",
        "columns": {"mappingMode": "defineBelow", "value": {"Status": "Rendered", "Final_Video_URL": "={{ $json.submagic_video_url }}"}},
        "options": {}
      },
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [2320, 2350],
      "id": "update-script-rendered-s3s4",
      "name": "Update Script: Rendered",
      "credentials": {
        "airtableTokenApi": {
          "id": "h68hvDXg5Xigfz5P",
          "name": "Airtable Personal Access Token account"
        }
      }
    },

    {
      "parameters": {
        "jsCode": "console.error('Submagic FAILED for project:', $json.submagic_project_id, 'Status:', $json.submagic_current_status);\nreturn [{ json: { error: 'Submagic rendering failed', ...$json } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 1,
      "position": [2320, 2440],
      "id": "handle-submagic-failure-s3s4",
      "name": "Handle Submagic Failure"
    },

    {
      "parameters": {
        "operation": "update",
        "base": {"__rl": true, "value": "={{ $env.AIRTABLE_BASE_ID }}", "mode": "id"},
        "table": {"__rl": true, "value": "={{ $env.AT_TABLE_SCRIPT_LIB }}", "mode": "id"},
        "recordId": "={{ $json.airtable_record_id }}",
        "columns": {"mappingMode": "defineBelow", "value": {"Status": "Failed", "Feedback": "={{ 'Submagic render failed. Status: ' + ($json.submagic_current_status || 'unknown') }}"}},
        "options": {}
      },
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2.1,
      "position": [2480, 2440],
      "id": "mark-script-failed-s3s4",
      "name": "Mark Script: Failed",
      "credentials": {
        "airtableTokenApi": {
          "id": "h68hvDXg5Xigfz5P",
          "name": "Airtable Personal Access Token account"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "Get Analyzed Content": {
      "main": [
        [
          {
            "node": "Filter: Status = Generate Script",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter: Status = Generate Script": {
      "main": [
        [
          {
            "node": "Generate Video Script",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gemini 2.0 Script": {
      "ai_languageModel": [
        [
          {
            "node": "Generate Video Script",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Generate Video Script": {
      "main": [
        [
          {
            "node": "Parse AI Script",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse AI Script": {
      "main": [
        [
          {
            "node": "Store Script in Library",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Trigger Generate Script": {
      "main": [
        [
          {
            "node": "Get Analyzed Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schedule Trigger (Every 12h)": {
      "main": [
        [
          {
            "node": "Generate Global URLs",
            "type": "main",
            "index": 0
          },
          {
            "node": "Generate Reddit URLs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Global URLs": {
      "main": [
        [
          {
            "node": "Fetch Google Trends RSS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Google Trends RSS": {
      "main": [
        [
          {
            "node": "Parse All Trends (Full Metadata)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse All Trends (Full Metadata)": {
      "main": [
        [
          {
            "node": "Filter Viral Trends (500+)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter Viral Trends (500+)": {
      "main": [
        [
          {
            "node": "Merge: Google Trends + Reddit",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Reddit URLs": {
      "main": [
        [
          {
            "node": "Fetch Reddit Posts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Reddit Posts": {
      "main": [
        [
          {
            "node": "Parse Reddit Posts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Reddit Posts": {
      "main": [
        [
          {
            "node": "Merge: Google Trends + Reddit",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge: Google Trends + Reddit": {
      "main": [
        [
          {
            "node": "Gemini: Viral Scout",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gemini 2.0 (Scout)": {
      "ai_languageModel": [
        [
          {
            "node": "Gemini: Viral Scout",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Gemini: Viral Scout": {
      "main": [
        [
          {
            "node": "Top Viral Bangers",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Top Viral Bangers": {
      "main": [
        [
          {
            "node": "Store in Inspiration DB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store in Inspiration DB": {
      "main": [
        []
      ]
    },
    "Trigger Scraping Run": {
      "main": [
        [
          {
            "node": "Read Inspiration DB (Pending)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Inspiration DB (Pending)": {
      "main": [
        [
          {
            "node": "Gemini: Hashtag Optimizer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gemini: Hashtag Optimizer": {
      "main": [
        [
          {
            "node": "Parse Keywords",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gemini 2.0 (Optimizer)": {
      "ai_languageModel": [
        [
          {
            "node": "Gemini: Hashtag Optimizer",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Parse Keywords": {
      "main": [
        [
          {
            "node": "Apify: Scrape Instagram Reels",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apify: Scrape Instagram Reels": {
      "main": [
        [
          {
            "node": "Normalize Reel Metadata",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Reel Metadata": {
      "main": [
        [
          {
            "node": "Fetch Subtitles (SRT)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Subtitles (SRT)": {
      "main": [
        [
          {
            "node": "Clean Subtitles",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clean Subtitles": {
      "main": [
        [
          {
            "node": "Analyze Viral Content (Gemini)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Analyze Viral Content (Gemini)": {
      "main": [
        [
          {
            "node": "Parse Gemini Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gemini 2.0 Flash": {
      "ai_languageModel": [
        [
          {
            "node": "Analyze Viral Content (Gemini)",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Parse Gemini Analysis": {
      "main": [
        [
          {
            "node": "Store in Viral Content DB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Manual Discovery Trigger": {
      "main": [
        [
          {
            "node": "Generate Global URLs",
            "type": "main",
            "index": 0
          },
          {
            "node": "Generate Reddit URLs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Manual Trigger (Stage 3)": {
      "main": [[{"node": "Get Approved Scripts", "type": "main", "index": 0}]]
    },
    "Get Approved Scripts": {
      "main": [[{"node": "Filter: Has Scripts?", "type": "main", "index": 0}]]
    },
    "Filter: Has Scripts?": {
      "main": [[{"node": "Prepare Full Script", "type": "main", "index": 0}]]
    },
    "Prepare Full Script": {
      "main": [[{"node": "Prepare ElevenLabs Request", "type": "main", "index": 0}]]
    },
    "Prepare ElevenLabs Request": {
      "main": [[{"node": "Generate Voice (ElevenLabs)", "type": "main", "index": 0}]]
    },
    "Generate Voice (ElevenLabs)": {
      "main": [[{"node": "Attach Audio + Metadata", "type": "main", "index": 0}]]
    },
    "Attach Audio + Metadata": {
      "main": [[{"node": "Upload Audio to HeyGen", "type": "main", "index": 0}]]
    },
    "Upload Audio to HeyGen": {
      "main": [[{"node": "Merge Audio Asset ID", "type": "main", "index": 0}]]
    },
    "Merge Audio Asset ID": {
      "main": [[{"node": "HeyGen: Generate Avatar (Green Screen)", "type": "main", "index": 0}]]
    },
    "HeyGen: Generate Avatar (Green Screen)": {
      "main": [[{"node": "Extract HeyGen Video ID", "type": "main", "index": 0}]]
    },
    "Extract HeyGen Video ID": {
      "main": [[{"node": "Wait 10 Min (HeyGen)", "type": "main", "index": 0}]]
    },
    "Wait 10 Min (HeyGen)": {
      "main": [[{"node": "Poll HeyGen Status", "type": "main", "index": 0}]]
    },
    "Poll HeyGen Status": {
      "main": [[{"node": "Classify HeyGen Status", "type": "main", "index": 0}]]
    },
    "Classify HeyGen Status": {
      "main": [[{"node": "Filter: HeyGen Ready?", "type": "main", "index": 0}]]
    },
    "Filter: HeyGen Ready?": {
      "main": [[{"node": "Fetch Viral Content (B-roll)", "type": "main", "index": 0}]]
    },
    "Fetch Viral Content (B-roll)": {
      "main": [[{"node": "Extract Viral B-Roll URL", "type": "main", "index": 0}]]
    },
    "Extract Viral B-Roll URL": {
      "main": [[{"node": "Extract Scene Narrative (for VEO)", "type": "main", "index": 0}]]
    },
    "Extract Scene Narrative (for VEO)": {
      "main": [[{"node": "VEO: Generate Real Footage", "type": "main", "index": 0}]]
    },
    "VEO: Generate Real Footage": {
      "main": [[{"node": "Extract VEO Task ID", "type": "main", "index": 0}]]
    },
    "Extract VEO Task ID": {
      "main": [[{"node": "Wait 10 Min (VEO)", "type": "main", "index": 0}]]
    },
    "Wait 10 Min (VEO)": {
      "main": [[{"node": "Poll VEO Status", "type": "main", "index": 0}]]
    },
    "Poll VEO Status": {
      "main": [[{"node": "Classify VEO Status", "type": "main", "index": 0}]]
    },
    "Classify VEO Status": {
      "main": [[{"node": "Merge All Assets Data", "type": "main", "index": 0}]]
    },
    "Merge All Assets Data": {
      "main": [[{"node": "Update Script: Pending Submagic", "type": "main", "index": 0}]]
    },
    "Update Script: Pending Submagic": {
      "main": [[{"node": "Submit to Submagic", "type": "main", "index": 0}]]
    },
    "Submit to Submagic": {
      "main": [[{"node": "Extract Submagic Project ID", "type": "main", "index": 0}]]
    },
    "Extract Submagic Project ID": {
      "main": [[{"node": "Wait 5 Min (Submagic)", "type": "main", "index": 0}]]
    },
    "Wait 5 Min (Submagic)": {
      "main": [[{"node": "Poll Submagic Status", "type": "main", "index": 0}]]
    },
    "Poll Submagic Status": {
      "main": [[{"node": "Evaluate Submagic Status", "type": "main", "index": 0}]]
    },
    "Evaluate Submagic Status": {
      "main": [[{"node": "Is Submagic Complete?", "type": "main", "index": 0}]]
    },
    "Is Submagic Complete?": {
      "main": [[{"node": "Update Script: Rendered", "type": "main", "index": 0}], [{"node": "Handle Submagic Failure", "type": "main", "index": 0}]]
    },
    "Update Script: Rendered": {
      "main": [[]]
    },
    "Handle Submagic Failure": {
      "main": [[{"node": "Mark Script: Failed", "type": "main", "index": 0}]]
    },
    "Mark Script: Failed": {
      "main": [[]]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "availableInMCP": false
  },
  "versionId": "558388d5-9346-436d-86a3-3bb0c5249c6a",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "dc87f94e8f44b5018e54a588eebeaae61eebdb6c256f8f2f61b7c6ba347bca63"
  },
  "id": "0ZSLiDZcYmBRLfgI",
  "tags": []
}